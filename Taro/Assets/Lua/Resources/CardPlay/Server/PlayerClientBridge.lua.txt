--服务端和客户端的沟通桥接
require 'CardPlay.Common.Poke'

local BridgeData = {}

function BridgeData:NewData(server)
    local data = setmetatable({}, {__index = BridgeData})
    data.state = server.state
    if data.state == State.chooseTaro then
        data.chooseTaroStep = server.chooseTaroStep
    elseif data.state == State.deal then
        data.dealStep = server.dealStep
    elseif data.state == State.playCard then
        data.playCardStep = server.playCardStep
    end
    return data
end

Bridge = {}

function Bridge:New(client, player)
    local bridge = {}
    self.client = client
    self.player = player
    self.server = player.server
    setmetatable(bridge, {__index = Bridge})
    return bridge
end

local function wrapPlayerInfo_ReadyState(player)
    local info = {
        ready = player.ready,
        connected = player.connected,
    }
    return info
end

local function createData_ReadyState(bridge)
    local server = bridge.server
    local data = BridgeData:NewData(server)
    local me = server.players[1]
    local downstream = server.players[2]
    local upstream = server.players[3]

    data.meInfo = wrapPlayerInfo_ReadyState(me)
    data.downstreamInfo = wrapPlayerInfo_ReadyState(downstream)
    data.upstreamInfo = wrapPlayerInfo_ReadyState(upstream)
    return data;
end

local function wrapPlayerInfo_DealState(player, isSelf)
    local info = { }
    info.isSelf = isSelf
    if isSelf then
        info.hands = {}
        for index, poke in ipairs(player.hands) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(info.hands, poke2)
        end
    end
    info.handNum = #player.hands
    return info
end

local function createData_DealState(bridge)
    local server = bridge.server
    local data = BridgeData:NewData(server)
    local me = server.players[1]
    local downstream = server.players[2]
    local upstream = server.players[3]

    data.meInfo = wrapPlayerInfo_DealState(me, true)
    data.downstreamInfo = wrapPlayerInfo_DealState(downstream, false)
    data.upstreamInfo = wrapPlayerInfo_DealState(upstream, false)
    return data;
end

local function wrapPlayerInfo_PlayCardState(player, isSelf, isTurnPlayer)
    local info = { }
    info.isSelf = isSelf
    if isSelf then
        info.hands = {}
        for index, poke in ipairs(player.hands) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(info.hands, poke2)
        end
    end
    info.board = {}
    if player.board ~= nil then
        for index, poke in ipairs(player.board) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(info.board, poke2)
        end
    end
    info.handNum = #player.hands
    info.isTurnPlayer = isTurnPlayer
    info.giveUp = player.giveUp
    return info
end

local function createData_PlayCardState(bridge)
    local server = bridge.server
    local data = BridgeData:NewData(server)
    local me = server.players[1]
    local downstream = server.players[2]
    local upstream = server.players[3]
    local currentTurn = bridge.server.currentTurn
    data.meInfo = wrapPlayerInfo_PlayCardState(me, true, currentTurn == 1)
    data.downstreamInfo = wrapPlayerInfo_PlayCardState(downstream, false, currentTurn == 2)
    data.upstreamInfo = wrapPlayerInfo_PlayCardState(upstream, false, currentTurn == 3)

    data.lastPlayCards = {}
    if server.lastPlayCards ~= nil then
        for index, poke in ipairs(server.lastPlayCards) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(data.lastPlayCards, poke2)
        end
    end

    return data;
end

local function wrapPlayerInfo_SettleState(player, isSelf, isWinner)
    local info = { }
    info.isSelf = isSelf
    if isSelf then
        info.hands = {}
        for index, poke in ipairs(player.hands) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(info.hands, poke2)
        end
    end
    info.board = {}
    if player.board ~= nil then
        for index, poke in ipairs(player.board) do
            local poke2 = Poke.newCard(poke.figure, poke.pattern)
            table.insert(info.board, poke2)
        end
    end
    info.handNum = #player.hands
    info.isWinner = isWinner
    info.giveUp = player.giveUp
    return info
end

local function createData_SettleState(bridge)
    local server = bridge.server
    local data = BridgeData:NewData(server)
    local me = server.players[1]
    local downstream = server.players[2]
    local upstream = server.players[3]
    local currentTurn = bridge.server.currentTurn
    data.meInfo = wrapPlayerInfo_SettleState(me, true, server.winner == server.players[1])
    data.downstreamInfo = wrapPlayerInfo_SettleState(downstream, false, server.winner == server.players[2])
    data.upstreamInfo = wrapPlayerInfo_SettleState(upstream, false, server.winner == server.players[3])

    return data;
end

--client 2 server--

function Bridge:C2S_RequestData_ReadyState()
    local data = createData_ReadyState(self)
    self.client:UpdateUI_ReadyState(data)
end

function Bridge:C2S_SetReady_ReadyState(ready)
    self.player:setReady(ready, true)
end

function Bridge:C2S_Done_DealState()
    self.player:Done_DealState()
end

function Bridge:C2S_MakeDecision_PlayCardState(result, cards)
    if self.cardPlayCallback ~= nil then
        self.cardPlayCallback(result, cards)
        self.cardPlayCallback = nil
    end
end

function Bridge:C2S_OnWinnerDialogBtnClick()
    self.player:completeSettleState()
end

--server 2 client--

function Bridge:S2C_onPlayerConnected(player, connected)
    local data = createData_ReadyState(self)
    self.client:UpdateUI_ReadyState(data)
end

function Bridge:S2C_onPlayerReady(player, ready)
    local data = createData_ReadyState(self)
    self.client:UpdateUI_ReadyState(data)
end

function Bridge:S2C_endReadyState()
    self.client:endReadyState()
end

function Bridge:S2C_startDealState()
    self.client:startDealState()
end

function Bridge:S2C_afterDeal_DealState()
    local data = createData_DealState(self)
    self.client:afterDeal_DealState(data)
end

function Bridge:S2C_startPlayCardState_PlayCardState()
    local data = createData_PlayCardState(self)
    self.client:startPlayCardState_PlayCardState(data)
end

function Bridge:S2C_notifyPlayCardAction_PlayCardState()
    local data = createData_PlayCardState(self)
    self.client:notifyPlayCardAction_PlayCardState(data)
end

function Bridge:S2C_makePlayCardDecision_PlayCardState(callback)
    self.cardPlayCallback = callback
    self.client:makePlayCardDecision_PlayCardState()
end

function Bridge:S2C_startSettleState()
    local data = createData_SettleState(self)
    self.client:startSettleState(data)
end

function Bridge:S2C_restartReadyState()
    local data = createData_ReadyState(self)
    self.client:restartReadyState(data)
end